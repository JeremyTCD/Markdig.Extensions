<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Threading" #>
<#
    var specFiles = new KeyValuePair<string, string>[] {
		new KeyValuePair<string, string>(Host.ResolvePath("../../Specs/CommonMarkSpecs.md"), "commonmark"),
		new KeyValuePair<string, string>(Host.ResolvePath("../../Specs/SectionsSpecs.md"), "sections|all"),
		new KeyValuePair<string, string>(Host.ResolvePath("../../Specs/JsonOptionsSpecs.md"), "jsonoptions_sections")
	};
#>
using Xunit;

namespace JeremyTCD.Markdig.Extensions.Tests.Specs
{
<#
foreach (KeyValuePair<string, string> specFileItem in specFiles)
{
	string specFile = specFileItem.Key;
    string[] pipelines = specFileItem.Value.Split('|');
    List<Extension> extensions = Parser.ParseSpecs(specFile);

    foreach (Extension extension in extensions)
    {
        bool firstSpec = true;
#><#= !string.IsNullOrWhiteSpace(extension.Description) ? "\n" + extension.Description : string.Empty #>
    public class <#= extension.Name #>Tests
    {
<#  
        foreach (Spec spec in extension.Specs)
        {
            foreach (string pipeline in pipelines)
            {
#><#= !string.IsNullOrWhiteSpace(spec.Description) ? (!firstSpec ? "\n" : string.Empty) + spec.Description : string.Empty #>
        [Fact]
        public void <#= extension.Name #>_Spec<#= spec.Number #>_<#= pipeline #>()
        {
            // The following Markdown:
<#= spec.MarkdownAsComment #>
            <#
                if(!string.IsNullOrWhiteSpace(spec.ExtensionOptionsAsComment))
                {
            #>//
            // With extension options:
<#= spec.ExtensionOptionsAsComment #>
            <#
                }
            #>//
            // Should be rendered as:
<#= spec.HtmlAsComment #>

            SpecTestHelper.AssertCompliance("<#= spec.Markdown #>", 
                "<#= spec.Html #>", 
                "<#= pipeline #>"<# if(!string.IsNullOrWhiteSpace(spec.ExtensionOptions))
                {
#>, 
                "<#= spec.ExtensionOptions #>"<#
                }
#>);
        }
<#
                firstSpec = false;
            }
        }
#>    }
<#
    }
}
#>}

<#+
public class Extension
{
    public string Name { get; set; }
    public List<Spec> Specs { get; set; } = new List<Spec>();
    public string Description { get; set; }
}

public class Spec
{
    public string ExtensionOptions { get; set; }
    public string ExtensionOptionsAsComment { get; set; }
    public string Markdown { get; set; }
    public string MarkdownAsComment { get; set; }
    public string Html { get; set; }
    public string HtmlAsComment { get; set; }
    public int Number { get; set; }
    public string Description { get; set; }
}

public class Parser
{
    private enum ParseStage
    {
        PreSpec,
        ExtensionOptions,
        Markdown,
        Html
    }

    private static ParseStage stage;
    private static Extension currentExtension;
    private static string currentDescription;
    private static string closestHeading;
    private static bool end;
    private static List<Extension> result;
    private static List<string> extensionOptionsLines;
    private static List<string> markdownLines;
    private static List<string> htmlLines;
    private static int currentSpecNumber;

    public static List<Extension> ParseSpecs(string fileName)
    {
        // Reset everything (static variable are ugly but efficient, so long as this method is never
        // called in parallel, in which case a local state object could be used instead)
        stage = ParseStage.PreSpec;
        currentExtension = null;
        currentDescription = "";
        closestHeading = null;
        end = false;
        result = new List<Extension>();
        extensionOptionsLines = new List<string>();
        markdownLines = new List<string>();
        htmlLines = new List<string>();
        currentSpecNumber = 1;

        string content = File.ReadAllText(fileName);
        string line;

        using (var reader = new StringReader(content))
        {
            while (!end && (line = reader.ReadLine()) != null)
            {
                if (stage == ParseStage.PreSpec)
                {
                    PreSpecStageHandleLine(line);
                }
                else if (stage == ParseStage.ExtensionOptions)
                {
                    ExtensionOptionsStageHandleLine(line);
                }
                else if (stage == ParseStage.Markdown)
                {
                    MarkdownStageHandleLine(line);
                }
                else if (stage == ParseStage.Html)
                {
                    HtmlStageHandleLine(line);
                }
            }
        }

        return result;
    }

    private static void MarkdownStageHandleStart()
    {
        if (currentExtension == null)
        {
            int descriptionEnd = currentDescription.Trim().LastIndexOf("\n\n");
            string description = string.Empty;
            if (descriptionEnd != -1)
            {
                description = currentDescription.Substring(0, descriptionEnd);
                currentDescription = currentDescription.Substring(descriptionEnd + 2);
            }
            else
            {
                description = currentDescription;
                currentDescription = "";
            }

            currentExtension = new Extension()
            {
                Name = NormalizeHeading(closestHeading),
                Description = ToComment(description.Trim(), "    ")
            };
            result.Add(currentExtension);
        }
    }

    private static void ExtensionOptionsStageHandleLine(string line)
    {
        if (line == "```````````````````````````````` example")
        {
            MarkdownStageHandleStart();

            stage = ParseStage.Markdown; // parse markdown
            return;
        }

        if (!string.IsNullOrWhiteSpace(line))
        {
            extensionOptionsLines.Add(line);
        }
    }

    private static void PreSpecStageHandleLine(string line)
    {
        if (line == "```````````````````````````````` options")
        {
            stage = ParseStage.ExtensionOptions;
            return;
        }

        if (line == "```````````````````````````````` example")
        {
            MarkdownStageHandleStart();

            stage = ParseStage.Markdown; // parse markdown
            return;
        }

        if (line == "<!-- END TESTS -->")
        {
            end = true;
            return;
        }

        Match match = Regex.Match(line, @"## ([ \w]+)");
        if (match.Success)
        {
            closestHeading = match.Groups[1].Value;

            if (currentExtension != null)
            {
                currentExtension = null;
            }

            currentDescription = "";
            return;
        }

        currentDescription += line + '\n';
    }

    private static void MarkdownStageHandleLine(string line)
    {
        if (line == ".")
        {
            stage = ParseStage.Html;
            return;
        }

        markdownLines.Add(line);
    }

    private static void HtmlStageHandleLine(string line)
    {
        if (line == "````````````````````````````````")
        {
            string markdown = string.Join("\n", markdownLines.ToArray());
            string html = string.Join("\n", htmlLines.ToArray());
            string extensionOptions = string.Join("\n", extensionOptionsLines.ToArray());

            currentExtension.
                Specs.
                Add(new Spec()
                {
                    Html = Escape(html),
                    HtmlAsComment = ToComment(html, "            ", "     "),
                    Markdown = Escape(markdown),
                    MarkdownAsComment = ToComment(markdown, "            ", "     "),
                    Number = currentSpecNumber,
                    Description = ToComment(currentDescription.Trim(), "        "),
                    ExtensionOptions = Escape(extensionOptions),
                    ExtensionOptionsAsComment = ToComment(extensionOptions, "            ", "     ")
                });

            htmlLines.Clear();
            markdownLines.Clear();
            extensionOptionsLines.Clear();
            currentDescription = "";
            currentSpecNumber++;

            stage = ParseStage.PreSpec;

            return;
        }

        htmlLines.Add(line);
    }

    private static string ToComment(string text, string commentIndentation = "", string contentIndentation = " ")
    {
        if (string.IsNullOrWhiteSpace(text))
        {
            return string.Empty;
        }

        return $"{commentIndentation}//{contentIndentation}" + text.Replace("\n", $"\n{commentIndentation}//{contentIndentation}");
    }

    private static string NormalizeHeading(string heading)
    {
        return Thread.CurrentThread.CurrentCulture.TextInfo.ToTitleCase(heading).Replace(" ", "");
    }

    private static string Escape(string input)
    {
        return input
            .Replace("→", "\t")
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\0", "\\0")
            .Replace("\a", "\\a")
            .Replace("\b", "\\b")
            .Replace("\f", "\\f")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t")
            .Replace("\v", "\\v");
    }
}
#>